# 아이템 19 - 상속을 고려해 설계하고 문서화하라. 그러지 않다면 상속을 금지하라

상속을 허용하는 클래스를 위해서 지켜야 할 제약들에 대해 알아볼 것이다.

📌 **정리**

우린 **상속을 고려하여 설계**하고, **문서화**해야 하며, 구체적으로 다음과 같은 네 가지를 명심하자.

1. 클래스 내부에서 스스로를 어떻게 사용하는지(자기 사용 패턴)를 모두 문서로 남기기
2. 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 한다.
3. 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안된다.
4. 클래스를 확장해야 할 명확한 이유가 없다면, 애초에 상속을 금지하자.

## 1. 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지, 이를 호출할 수 있는 모든 상황을 (자기사용) 문서로 남겨야 한다.

- 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적어야 한다.
- 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지 담아야 한다.
- 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다. 그렇지 않으면, 이 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 것이다.

(* 재정의 가능이란 public, protected 메서드 중 final이 아닌 모든 메서드를 뜻한다.)

- 좋은 API 문서는 ‘어떻게’가 아닌 ‘무엇’을 하는지를 설명해야 한다는 격언이 있다.
    
    그러나, API들은 특정 클래스의 메서드를 재정의하면 이 내부의 다른 메서드의 동작에 주는 영향까지 정확하게 설명을 하고 있다. 
    
    이는 상속이 캡슐화를 해치기 때문에 클래스를 안전하게 상속하려면 내부 구현 방식을 잘 설명해야 하기 때문이다.
    

- API 문서의 메서드 설명 끝에서 Implementation Requirements 로 시작하는 절이 바로 메서드의 내부 동작 방식을 설명하는 곳이다. 이 절은 메서드 주석에 @implSpec 태그(자바 8 부터)를 붙여주면 자바독 도구가 생성해준다.

https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html#remove-java.lang.Object-

## 2. 클래스의 내부 동작 과정 중간에 끼어둘 수 있는 훅을 잘 선별하여 protected 메서드 형태로 또 드물게는 protected 필드로 공개해야 할 수도 있다.

- 꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러난다.
- 거꾸로, 하위클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private 이었어야 할 가능성도 있다.

- protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 적어야 한다. 근데 또 한편으로는 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 한다.

**그렇다면, 상속용 클래스를 설계할 때, 어떤 메서드를 protected로 노출해야 하는 것인가?**

**⇒ 직접 하위 클래스를 만들어보는 것이 유일하다.**

**우리가 널리 쓰일 클래스를 상속용으로 설계한다면?**

문서화한 내부 사용패턴과 protected 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 한다. 이 결정들이 그 클래스의 성능과 기능을 좌지우지할 것이다. 

상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어서 검증해야 한다. 

## 3. 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.

private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 되지만,

이외는 재정의 가능한 메서드이다. 

만약, 이 재정의 가능한 메서드를 만약, 상속용 클래스의 생성자가 호출하게 된다면?

상위 클래스의 생성자가 하위클래스의 생성자보다 먼저 실행되므로

하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출되게 된다.

이때 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면

의도대로 동작하지 않고 프로그램이 오동작할 것이다.

**ex) 이 규칙을 어긴 경우,**

```java
public class Super {
    
    public Super() {
        overrideMe(); // 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다. 
    }

    // 재정의 가능 메서드
    public void overrideMe() {

    }
}
```

```java
public class Sub extends Super {

    private final Instant instant;

    Sub() {
        instant = Instant.now();
    }

    // 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다.
    @Override
    public void overrideMe() {
		
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

하위 클래스의 생성자가 인스턴스 필드를 초기화하기도 전에, 

상위 클래스의 생성자가 overrideMe를 호출하고 있다.

그렇기에 상위 클래스의 생성자가 overrideMe를 호출할 때, Null이 찍히는 것.

---

## 4. Cloneable과 Serializable 둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하지마라. 만약, 설계한다면 다음과 같은 제약을 지켜라.

이 클래스를 확장하는 것은 프로그래머에게 엄청난 부담이다.

만약, 원한다면, 이 인터페이스들을 하위 클래스에서 구현하도록 하는 특별한 방법이 있긴 하다. (item 13, item 86)

clone 과 readObject 메서드는 새로운 객체를 만드는 것 처럼 생성자와 비슷한 효과를 낸다.

따라서 상속용 클래스에서 Cloneable이나 Serializable을 구현할지 정해야 한다면,

이들을 구현할 때 따르는 제약도 생성자와 비슷하다고 생각하면 된다.

1.  **즉, 3번과 같은 맥락으로, 이들을 구현한다면,**
    
    **clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출하면 안된다.** 
    

    **만약, 이를 어긴다면?**

    - readObject의 경우, 하위 클래스의 상태가 미처다 역직렬화되기 전에 재정의한 메서드부터 호출하게 된다.
    - clone의 경우 하위 클래스의 clone 메서드가 복제본의 상태를 수정하기 전에 재정의한 메서드를 호출하게 된다. 특히 clone이 잘못되면 복제본뿐만 아니라, 원본 객체에도 피해를 줄 수 있다.

2.  **Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면, 이 메서드들을 private이 아닌 protected로 선언해야 한다.**

    private으로 선언한다면 하위 클래스에서 무시되기 때문이다. 이 역시 상속을 허용하기 위해 내부 구현을 클래스 API로 공개하는 예 중 하나이다.

## 5. 상속용으로 설계하지 않는 클래스는 상속을 금지시키자.

전통적으로 일반적인 구체 클래스는 final도 아니고 상속용으로 설계되거나 문서화되지도 않았다. 

하지만 그대로 둔다면, 클래스에 변화가 생길 때마다 하위 클래스를 오동작하게 만들 수 있다.

실제로 보통의 구체 클래스를 그 내부만 수정했음에도 이를 확장한 클래스에서 문제가 생기곤 한다.

이 문제를 해결하기 위해 상속용으로 설계하지 않는 클래는 상속을 금지하는 것이다.

### 상속을 금지하는 방법

*둘 중 어느 방법이든 좋고, 더 쉬운 쪽은 1번 방법*

1. 클래스를 final로 선언하는 방법
2. 모든 생성자를 private이나 package-private으로 선언하고 public 정적 ㅐㄱ터리를 만들어주는 방법

하지만, 이 부분에 있어선 다소 논란의 여지가 있다.

구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해진다.

### 만약, **이런 클래스라도 상속을 꼭 허용해야겠다면,**

**클래스 내부에서 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기자.**

재정의 가능 메서드를 호출하는 자기 사용코드를 완벽하게 제거해서

메서드를 재정의해도 다른 메서드의 동작에 아무런 영향을 주지 않게 하여, 상속을 해도 그리 위험하지 않는 클래스를 만드는 것이다. 

### 클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 방법

- 먼저, 각각의 가능 메서드는 자신의 본문 코드를 priavate 도우미 메서드로 옮기고, 이 도우미 메서드를 호출하도록 수정한다.
- 그런 다음 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정하면 된다.